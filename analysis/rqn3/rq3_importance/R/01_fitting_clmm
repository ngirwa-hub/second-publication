# 02_fit_clmm_importance_multiarm.R  (fixed to use condition5)
options(contrasts = c("contr.treatment", "contr.poly"))

suppressPackageStartupMessages({
  library(ordinal); library(tidyverse); library(broom)
})

out_dir <- "imp_multiarm_outputs"
df <- readRDS(file.path(out_dir, "df_prepped_importance_multiarm.rds"))

# Keep rating levels 0:4 no matter what
df$rating <- ordered(as.integer(as.character(df$rating)), levels = 0:4)

# Only drop levels on predictors (optional)
df$condition5  <- droplevels(df$condition5)
df$base_model  <- droplevels(df$base_model)
df$dc_solution <- droplevels(df$dc_solution)
# DO NOT: df <- droplevels(df)  # this would also drop rating levels

# sanity
#stopifnot("condition5" %in% names(df))
#df <- droplevels(df)

write_csv_safely <- function(x, path){
  dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
  if (file.exists(path)) file.remove(path)
  readr::write_csv(x, path)
  message("Wrote: ", normalizePath(path, winslash="\\", mustWork = FALSE),
          " (rows=", nrow(x), ")")
}

# ---- CLMM (single overall fit) ----
m <- clmm(
  rating ~ condition5 * base_model + (1 | pair_id) + (1 | dc_solution),
  data = df, link = "logit", Hess = TRUE
)
thr_names <- grep("\\|", names(coef(m)), value = TRUE)
K <- length(thr_names) + 1L
message("Detected K=", K, " response categories in the fitted model. Thresholds: ",
        paste(thr_names, collapse=", "))
message("Levels(df$rating) before fitting: ", paste(levels(df$rating), collapse=", "))
message("Counts by rating:"); print(table(df$rating, useNA = "ifany"))


dir.create(file.path(out_dir, "summaries"), showWarnings = FALSE)
sink(file.path(out_dir, "summaries", "importance_multiarm_overall_summary.txt"))
cat("=== IMPORTANCE CLMM (multi-arm) ===\n")
print(summary(m))
sink()

co  <- broom::tidy(m, conf.int = FALSE)
V   <- stats::vcov(m)
beta_names <- rownames(V)

# ---- OR contrasts ----
make_contrast <- function(arm, bm) {
  t_main <- paste0("condition5", arm)
  t_int  <- paste0("condition5", arm, ":base_model", bm)
  cvec <- setNames(rep(0, length(beta_names)), beta_names)
  if (t_main %in% beta_names) cvec[t_main] <- 1
  if (t_int  %in% beta_names) cvec[t_int]  <- 1
  cvec
}

to_or <- function(est, se){
  lo <- est - 1.96*se; hi <- est + 1.96*se
  tibble::tibble(OR = exp(est), OR_l95 = exp(lo), OR_u95 = exp(hi))
}

make_or_table_for_arm <- function(arm) {
  purrr::map_dfr(levels(df$base_model), function(bm){
    cvec <- make_contrast(arm, bm)
    est  <- sum(cvec * coef(m)[beta_names], na.rm = TRUE)
    se   <- sqrt(as.numeric(t(cvec) %*% V %*% cvec))
    tibble::tibble(base_model = bm, arm = arm) %>% dplyr::bind_cols(to_or(est, se))
  })
}

arms <- c("ANCHOR_WORD","ANCHOR_EXAMPLE","ANCHOR_LOW_NUM","ANCHOR_HIGH_NUM")
or_all <- purrr::map_dfr(arms, make_or_table_for_arm)

dir.create(file.path(out_dir, "effects"), showWarnings = FALSE)
for (arm in arms) {
  write_csv_safely(
    dplyr::filter(or_all, arm == !!arm) %>% select(-arm),
    file.path(out_dir, "effects", paste0("OR_by_base_model_", arm, "_vs_CONTEXT.csv"))
  )
}
write_csv_safely(or_all, file.path(out_dir, "effects", "OR_by_base_model_ALL_arms_vs_CONTEXT.csv"))

# ---- Predicted P(Y>=3) by condition5 × base_model × dc_solution ----
grid <- expand.grid(
  condition5  = levels(df$condition5),
  base_model  = levels(df$base_model),
  dc_solution = levels(df$dc_solution),
  KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE
)
grid$condition5  <- factor(grid$condition5,  levels = levels(df$condition5))
grid$base_model  <- factor(grid$base_model,  levels = levels(df$base_model))
grid$dc_solution <- factor(grid$dc_solution, levels = levels(df$dc_solution))

dir.create(file.path(out_dir, "probs"), showWarnings = FALSE)

# ---- Helper for probabilities ----
.compute_probs_clmm <- function(mod, newdata, add_dc_solution_re = FALSE) {
  cf_all  <- coef(mod)
  thr_idx <- grep("\\|", names(cf_all))
  if (!length(thr_idx)) stop("No thresholds found in coef(mod).")
  thr_ord <- order(as.numeric(sub("\\|.*","", names(cf_all)[thr_idx])))
  theta   <- as.numeric(cf_all[thr_idx[thr_ord]])
  beta    <- cf_all[-thr_idx]; names(beta) <- names(cf_all)[-thr_idx]

  TT <- stats::delete.response(stats::terms(m))
  X  <- stats::model.matrix(TT, grid, contrasts.arg = m$contrasts)


  miss <- setdiff(names(beta), colnames(X))
  if (length(miss)) {
    X <- cbind(X, matrix(0, nrow = nrow(X), ncol = length(miss),
                         dimnames = list(NULL, miss)))
  }
  X <- X[, names(beta), drop = FALSE]

  eta <- as.numeric(X %*% beta)

  if (add_dc_solution_re) {
    re_list <- suppressWarnings(ranef(mod))
    if (is.null(re_list$dc_solution))
      stop("dc_solution random effects not available in ranef(mod).")
    dc_blup <- re_list$dc_solution[,"(Intercept)"]
    shift   <- dc_blup[match(as.character(newdata$dc_solution), names(dc_blup))]
    shift[is.na(shift)] <- 0
    eta <- eta + as.numeric(shift)
  }

  K <- length(theta) + 1L
  Fmat <- plogis(outer(theta, eta, function(th, e) th - e))
  Fmat <- t(Fmat)

  P <- matrix(NA_real_, nrow = nrow(newdata), ncol = K)
  P[, 1] <- Fmat[, 1]
  if (K > 2) P[, 2:(K - 1)] <- Fmat[, 2:(K - 1)] - Fmat[, 1:(K - 2)]
  P[, K] <- 1 - Fmat[, K - 1]
  stopifnot(all(abs(rowSums(P) - 1) < 1e-6))
  P
}

# --- Population-level probs (no RE) ---
P_pop <- .compute_probs_clmm(m, grid, add_dc_solution_re = FALSE)
#cats <- 0:(ncol(P_pop) - 1)
#geq_k <- 3
#ge_idx <- which(cats >= geq_k)
# Derive the actual category labels present in the fitted model
## ---------- after P_pop <- .compute_probs_clmm(...) ----------
# Derive actual category labels from threshold names "a|b"
thr_names  <- names(coef(m))[grepl("\\|", names(coef(m)))]
cat_labels <- sort(unique(as.numeric(unlist(strsplit(thr_names, "\\|")))))
stopifnot(length(cat_labels) == ncol(P_pop), all(!is.na(cat_labels)))

# Label the columns so downstream code uses real labels (e.g., 2,3,4)
colnames(P_pop) <- as.character(cat_labels)

## P(Y >= 3)
geq_k  <- 3
ge_idx <- which(cat_labels >= geq_k)

pr_pop <- dplyr::bind_cols(
  dplyr::as_tibble(grid),
  tibble::tibble(
    prob_geq    = if (length(ge_idx)) rowSums(P_pop[, ge_idx, drop = FALSE]) else 0,
    threshold_k = geq_k
  )
)
write_csv_safely(pr_pop, file.path(out_dir, "probs", "Pge3_by_condition5_base_model_solution_POP.csv"))

## P(Y >= top category) = probability of the max observed category
top_k       <- max(cat_labels)
ge_idx_top  <- which(cat_labels >= top_k)  # just the last column
pr_top <- dplyr::bind_cols(
  dplyr::as_tibble(grid),
  tibble::tibble(
    prob_ge_top = rowSums(P_pop[, ge_idx_top, drop = FALSE]),
    top_k       = top_k
  )
)
write_csv_safely(pr_top, file.path(out_dir, "probs", "PgeTOP_by_condition5_base_model_solution_POP.csv"))

## ---------- after P_withRE <- .compute_probs_clmm(..., TRUE) ----------
# Reuse the same labels (thresholds don’t change between POP and RE)
colnames(P_withRE) <- as.character(cat_labels)

pr_withRE_tbl <- dplyr::bind_cols(
  dplyr::as_tibble(grid),
  tibble::tibble(
    prob_geq    = if (length(ge_idx)) rowSums(P_withRE[, ge_idx, drop = FALSE]) else 0,
    threshold_k = geq_k
  )
)
write_csv_safely(pr_withRE_tbl, file.path(out_dir, "probs", "Pge3_by_condition5_base_model_solution_WITH_RE.csv"))
